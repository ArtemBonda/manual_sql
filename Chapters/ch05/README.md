
 ОСНОВЫ ЯЗЫКА ОПРЕДЕЛЕНИЯ ДАННЫХ
=================================

Представлены 2 таблицы «Студенты» (students) и «Успеваемость» (progress). В первой из них содержатся данные о студентах,
 а во второй — сведения об их успеваемости. Таблица «Успеваемость» будет `ссылающейся (referencing)`, а таблица «Студенты» —
 `ссылочной (referenced)`.

 При работе с БД нередко возникает ситуфция когда значение является типичным для
конкретного столбца(Пример для учета успеваемости студент заслуживает оценки "отлично"
 можно отразить это с помощью ключевогос лова `DEFAULT`)
```sql
CREATE TABLE progress(
...
    mark numeric(1) DEFAULT 5
);
```
# Ограничения (constraints)
## CHECK
После этого ключевого слова следует выражение в скобках, содержащее одно или несколько
условий, налагаемых на атрибуты таблицы. Они бывают 2ух видов:
* ограничение уровня атрибута ( является частью определения одного конкретного атрибута)
```sql
CREATE TABLE progress(
    ...
    term numeric(1) CHECK (term = 1 OR term = 2),
    mark numeric(1) CHECK (mark >= 3 OR mark <=5)
)
```
* уровня таблицы. (записывается как самостоятельный элемент определения таблицы)
```sql
CREATE TABLE progress(
...
    mark numeric(1)
    CONSTRAINT valid_mark CHECK (mark >= 3 OR mark <=5)
)
```
Различие только в синтаксическом оформлении, в ограничении таблицы сделал именованное ограничение,
которое в дольней облегчит понимание возникающих ошибок

### NOT NULL
Оно означает что в столбце таблицы на который наложео ограничение должно обязательно присутсвовать
какие-либо определенные значения

### UNIQUE
это `ограничение уникальности` приналожении на конкретный столбец значит что в этом столбце в различных
строках таблицы должны быть уникальными, т.е. не должны повторяться. Может быть и несколько стольбцов, в этом случае должна
быть уникальной комбинация этих значений
```sql
CREATE TABLE students (
    record_book numeric( 5 ) UNIQUE,
...
```
Это ограничение можно было бы записать и так, дав ему осмысленное имя
```sql
CREATE TABLE students (
    record_book numeric( 5 ),
    name text NOT NULL,
    ...
    CONSTRAINT unique_record_book UNIQUE ( record_book ),
    ...
);
```
комбинация значений серии и номера документа, удостоверяющего личность, является
уникальной. Поэтому можно модифицировать определение таблицы таким образом
```sql
CREATE TABLE students (
    ...
    doc_ser numeric( 4 ),
    doc_num numeric( 6 ),
    ...
    CONSTRAINT unique_passport UNIQUE ( doc_ser, doc_num ),
)
```
При добавлении ограничения уникальности автоматически создается индекс на основе B-дерева для поддержки этого ограничения.

### PRIMARY KEY
 `Первичный ключ` является уникальным идентификатором строк в таблице. Ключ может быть простым (включать только один атрибут),
 так и составным (включать более одного атрибута). Отлтчие его от UNIQUE, в том что у атрибутов PRIMARY KEY не может быть
 значения NULL. Теория Баз Данных подразумевает что в каждой таблице будет наличение первичного ключа.
 Первичный ключ состоит из одного атрибута, то можно его указать в непосредственно в определении этого атрибута:
 ```sql
 CREATE TABLE students (
    record_book numeric( 5 ) PRIMARY KEY,
    ...
 );
 ```
 В случае создания составного первичного ключа имена столбцов, входящих в его состав, перечисляются в выражении PRIMARY KEY через запятую:
 ```sql
 CREATE TABLE students(
    record_book numeric( 5 ),
    column2 text
    ...
    PRIMARY KEY ( record_book, column2 )
 );
 ```

 При добавлении первичного ключа автоматически создается индекс на основе B-дерева для поддержки этого ограничения.
 В таблице может быть любое число ограничений UNIQUE, дополненных ограничением NOT NULL, но первичный ключ может быть только один.
 PostgreSQL допускает и отсутствие первичного ключа, хотя строгая теория реляционных баз данных не рекомендует так поступать.

### FOREIGN KEY
 `Внешний ключ` - ключ является средством поддержания так называемой `ссылочной целостности (referential integrity)`между
 связанными таблицами

 Достаточно включить в состав каждой строки таблицы «Успеваемость» лишь уникальный идентификатор строки из таблицы «Студенты».
 В нашем случае это будет номер зачетной книжки — `record_book`. Данный атрибут и будет являться внешним ключом таблицы
 «Успеваемость». Таким образом, получив строку из таблицы «Студенты», можно будет найти все соответствующие ей строки
 в таблице «Успеваемость», сопоставив значения атрибутов `record_book` в строках обеих таблиц. В результате мы сможем получить
 все строки таблицы «Успеваемость», связанные с конкретной строкой из таблицы «Студенты» по внешнему ключу.

 Таблица «Успеваемость» будет `ссылающейся (referencing)`, а таблица «Студенты» — `ссылочной (referenced)`.

 Ограничение уровня атрибута:
 ```
 CREATE TABLE progress
 ( record_book numeric( 5 ) REFERENCES students ( record_book ),
     ...
 );
 ```
`REFERENCES` создает ограничение ссылочной целостности и указывает  в качестве ссылочного ключа атрибут `record_book`

 Поскольку `внешний ключ` в примере ссылается на `первичный ключ`, можно использовать сокращенную форму записи этого
 ограничения, не указывая список атрибутов:
 ```
 CREATE TABLE progress
 ( record_book numeric( 5 ) REFERENCES students,
 ...
 );
 ```
 Можно определить `внешний ключ` и в форме ограничения уровня таблицы:
 ```
 CREATE TABLE progress (
    record_book numeric( 5 ),
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
 );
```
 __________________________________________

 При наличии связей между таблицами, организованных с помощью внешних ключей, необходимо придерживаться определенной
 политики при выполнении операций удаления и обновления строк в ссылочных таблицах, т. е. в тех, на которые ссылаются другие таблицы.
 Cитуация принятия «политического» решения возникает при удалении строк из таблицы «Студенты» (students). Eсли было принято
 решение хранить всю историю успеваемости студентов, в том  числе и отчисленных, тогда строки из таблицы students вообще не удалялись бы. Но,
 упрощая реальную ситуацию, решаеми историю не хранить. Тогда возникает закономерный вопрос: что делать со строками в
 таблице «Успеваемость» (progress), которые ссылаются на удаляемую строку в таблице «Студенты» (students)? Возможны
 несколько вариантов:
 1. Удаление связанных строк из таблицы «Успеваемость» (progress), что означает, что при отчислении студента будет удаляться вся история его успехов в учебе.
 Эта операция называется каскадным удалением и для ее реализации в определение внешнего ключа добавляются ключевые слова `ON DELETE CASCADE`. Например:

 ```sql
 CREATE TABLE progress (
    record_book numeric( 5 ),
    ...
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON DELETE CASCADE
 );
 ```
 2.  . Запрет удаления строки из таблицы «Студенты» (students), если в таблице «Успеваемость» (progress) есть хотя бы одна строка,
 ссылающаяся на удаляемую строку в таблице «Студенты».  Kлючевые слова `ON DELETE RESTRICT` или `ON DELETE NO ACTION`. Если в определении внешнего ключа не предписано конкретное
 действие, то по умолчанию используется `NO ACTION`. Оба эти варианта означают, что если в ссылающейся таблице  «Успеваемость»,
 есть строки, ссылающиеся на удаляемую строку в таблице «Студенты», то операция удаления будет отменена, и будет выведено
 сообщение об ошибке. Отличие между этими двумя вариантами лишь в том, что при использовании `NO ACTION` можно отложить проверку
 выполнения ограничения на более поздний строк в рамках транзакции, а в случае `RESTRICT` проверка выполняется немедленно.
```
 CREATE TABLE progress (
    record_book numeric( 5 ),
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON DELETE RESTRICT
 );
 ```
или вот так
 ```
 CREATE TABLE progress
 ( record_book numeric( 5 ),
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
 );
 ```
 то при попытке удаления строки из таблицы «Студенты» и наличии в таблице«Успеваемость» строк, связанных с ней,
 операция удаления была бы отменена с выводом сообщения об ошибке.
3.  Присваивание атрибутам внешнего ключа в строках таблицы «Успеваемость» значения NULL. Для реализации этого
 подхода необходимо, чтобы на атрибуты внешнего ключа не было наложено ограничение NOT NULL.
 ```
 CREATE TABLE progress
 ( record_book numeric( 5 ),
     ...
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON DELETE SET NULL
 );
 ```
 4. Присваивание атрибутам внешнего ключа в строках таблицы «Успеваемость» (progress) значения DEFAULT, если оно, конечно,
 было предписано при создании таблицы. Оформляется этот вариант так (значение во фразе DEFAULT взято произвольное):
```
 CREATE TABLE progress (
    record_book numeric( 5 ) DEFAULT 12345,
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON DELETE SET DEFAULT
 );
 ```
 Важно учитывать, что если в ссылочной таблице нет строки с тем же значением  ключевого атрибута, которое было предписано
 во фразе DEFAULT при создании ссылающейся таблицы, то будет иметь место нарушение ограничения ссылочной целостности и
 операция удаления не будет выполнена

 При выполнении операции UPDATE используются эти же варианты подходов по отношению к обеспечению ссылочной целостности

```
 CREATE TABLE progress (
    record_book numeric( 5 ),
    ...
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON UPDATE CASCADE
 );
```

 После рассмотрения всех видов ограничений целостности базы данных мы можем  привести окончательные определения таблиц
 «Студенты» и «Успеваемость». Окончательными они являются лишь в том смысле, что именно их нужно брать за основу
 при выполнении заданий, приведенных в конце главы.

 Создать базу данных с помощью docker consol
```
 creatdb -U app edu
 ```
 Подключиться
 ```
 psql -d edu -U app
 ```
 Схема создания таблиц находиться в ch05_work.sql
 __________________________________________
 ## Создание и удаление таблиц
 Войти в БД
 ```
 psql -U app -d demo
 ```
 Узнать какие есть схемы в БД
 ```
 SHOW search_path;
 ```
 Если необходимо переключиться к другой БД не выходя из к утилиты psql
 ```
\connect demo
 ```
 или с короткой командой
 ```
 \c demo
 ```
 `Напомнить, что команды, имена которых начинаются с символа «\», не являются
 SQL-командами, а являются командами утилиты psql`

 Выбрать в качестве текущей схемы схему bookings
 ```
 SET search_path TO bookings;
 ```
 `bookings` - это Схема

 `Схема` - это раздел БД в котором создаются таблицы и другие объекты. По умолчанию используется
 схема `public`
При создании таблиц лучше всего добавлять коментарии с помощью ` -- `, а также в Postgres есть команда:
 ```
 COMMENT ON COLUMN table.field IS 'коментарий';
 ```
 Чтобы ы увидеть описания столбцов таблицы:
 ```
 \d+ table
 ```

 `Суррогатный ключ` —  это уникальный ключ, назначение которого — только идентифицировать строки в  таблице. Зачастую для
 него используются целочисленные значения. Такому ключу не  соответствует никакое свойство никакой сущности реального мира.
 Это — абстракция, позволяющая в ряде случаев упростить определения таблиц, например, за счет сокращения числа атрибутов
 во внешних ключах до одного.

 После создания таблиц, посмотреть описание таблиц или таблицы
 ```
 \d
 ```
 ```
 \d boarding_passes
 ```
Попробуем удалить таблицу `aircrafts
 ```
 DROP TABLE aircrafts;
 ```
 Будет выведено сообщение об ошибке, так как эта таблицы является ссылочной, и на нее ссылаются 2 таблицы
 `seats' и `flights` что и отражено в сообщении. Чтобы удалить использовать команду:
 ```
 DROP TABLE aircrafts CASCADE;
 ```
 При этом будет удалены из таблиц `seats' и `flights` внешние ключи, ссылающиеся на удаленную таблицы

 При повторном удалении этой таблицы, =>
 ```
 DROP TABLE aircrafts CASCADE;
 ```
 => будет выведено сообщение об ошибке, что таблица удалена. Чтобы избежать ненужных сообщений об ошибке отсутсвия таблицы
 ```
 DROP TABLE IF EXIST aircrafts CASCADE;
 ```
 `IF EXISTS` будет выведено замечание, а не ошибка. А также об успешном выполнении команды

 _____________________________________________________________
 ## Модификация таблиц
 Модифицировать таблицы приходится по различным причинам. При необходимости добавить к какому-нибудь атрибуту ограничение
 DEFAULT,  можно просто пересоздать, внеся изменения в их определения. Но если таблицы содержат большое
 количество строк, то пересоздать их не всегда возможно, в этом случае на помощь приходит команда `ALTER TABLE`

 `ALTER TABLE` - команда очень многообразна и логична. Она предусматривает все ситуации которые могут возникнуть в реальной
 работе. Ей в этом помогают фразы:

     * `ADD COLUMN` - добавить поле
     * `DROP COLUMN` - удалить поле
     * `ADD CHECK` - добавить
     * `ADD CONSTRAINT` - добавить ограничение
 При попытке выполнить эту команду СУБД выдает сообщение об ошибке
 ```
 ALTER TABLE aircrafts
     ADD COLUMN speed integer NOT NULL CHECK( speed >= 300 );
 ```
 Дело в том, что в таблице
 «Самолеты» (aircrafts) уже есть строки. Однако во время добавления тех строк столбец speed в таблице не присутствовал,
 поэтому при его добавлении сейчас значение  данного атрибута в этих строках будет отсутствовать, т. е. будет равно NULL.
 А мы наложили ограничение NOT NULL, следовательно, ранее добавленные строки не отвечают новому ограничению.

 Решение проблемы:
 1. Сначала добавить столбец, не накладывая никаких ограничений
 ```
 ALTER TABLE aircrafts ADD COLUMN speed integer;
 ```
 2. Ввести значения нового атрибута в уже существующие строки
 ```
 UPDATE aircrafts SET speed = 807 WHERE aircraft_code = '733';
 UPDATE aircrafts SET speed = 851 WHERE aircraft_code = '763';
 UPDATE aircrafts SET speed = 905 WHERE aircraft_code = '773';
 UPDATE aircrafts SET speed = 840
    WHERE aircraft_code IN ( '319', '320', '321' );
 UPDATE aircrafts SET speed = 786 WHERE aircraft_code = 'CR2';
 UPDATE aircrafts SET speed = 341 WHERE aircraft_code = 'CN1';
 UPDATE aircrafts SET speed = 830 WHERE aircraft_code = 'SU9';
 ```
 3. Наложить все необходимые ограничения
 ```
 ALTER TABLE aircrafts ALTER COLUMN speed SET NOT NULL;
 ALTER TABLE aircrafts ADD CHECK( speed >= 300 );
 ```
 Eсли необходимость наличия того или иного ограничения отпадет, его можно удалить:
```
 ALTER TABLE aircrafts ALTER COLUMN speed DROP NOT NULL;
 ALTER TABLE aircrafts DROP CONSTRAINT aircrafts_speed_check;
 ```
ВНИМАНИЕ, для удаления ограничения CHECK нужно указать его имя, которое можно выяснить с помощью команды
`\d aircrafts`

 Изменение типа данных у атрибута. Изменим тип данных для атрибутов «Координаты
 аэропорта: долгота» (longitude) и «Координаты аэропорта: широта» (latitude) с float
 (double precision) на numeric(5, 2)

 ```
 ALTER TABLE airports
    ALTER COLUMN longitude SET DATA TYPE numeric(5, 2)
    ALTER COLUMN latitude SET DATA TYPE numeric(5, 2);
 ```
 Когда один тип данных изменяется на другой тип данных в пределах одной группы, например, оба типа — числовые, то проблем
 обычно не возникает. В только что рассмотренном примере исходный тип данных был float (double precision), а новый —
 numeric(5, 2), поэтому операция замены типа прошла автоматически.Однако если исходный и целевой типы данных относятся к
 разным группам, тогда потребуются некоторые дополнительные усилия.

 Например необходимо создать таблицу, содержащую коды и наименования классов обслуживания. Назовем ее «Классы обслуживания»
 (fare_conditions). В ее состав включим два столбца: «Код класса обслуживания» и «Наименование класса обслуживания». Имена
 столбцам присвоим с учетом принципов формирования имен аналогичных столбцов в других  таблицах, например, в таблице «Аэропорты» (airports).
```
 CREATE TABLE fare_conditions (
    fare_conditions_code integer,
    fare_conditions_name varchar( 10 ) NOT NULL,
    PRIMARY KEY ( fare_conditions_code )
 );
 ```
 Добавить данные:
 ```
 INSERT INTO fare_conditions
    VALUES ( 1, 'Economy' ),
           ( 2, 'Business' ),
           ( 3, 'Comfort' );
 ```
 Поскольку ввели в обращение числовые коды для классов обслуживания, то необходимо модифицировать определение таблицы
 «Места» (seats), а именно: тип данных столбца «Класс обслуживания» (fare_conditions) изменить с varchar(10) на integer.
 Для реализации такой задачи служит фраза USING команды ALTER TABLE. Однако такой вариант команды не сработает:
```
 ALTER TABLE seats
    ALTER COLUMN fare_conditions SET DATA TYPE integer
    USING ( CASE WHEN fare_conditions = 'Economy' THEN 1
                WHEN fare_conditions = 'Business' THEN 2
                ELSE 3
            END );
```
 Для замены исходных значений на новые мы используем конструкцию `CASE WHEN ... THEN ... ELSE ... END`.

В определении таблицы есть ограничение `CHECK`, которое требует, чтобы значение столбца `fare_conditions` выбиралось из списка:
 «Economy», «Comfort», «Business». При замене символьных значений на числовые это ограничение будет заведомо нарушаться.
 Следовательно, необходимо в команду `ALTER TABLE` добавить операцию удаления этого ограничения.
```
 ALTER TABLE seats
    DROP CONSTRAINT seats_fare_conditions_check,
    ALTER COLUMN fare_conditions SET DATA TYPE integer
    USING ( CASE WHEN fare_conditions = 'Economy' THEN 1
                WHEN fare_conditions = 'Business' THEN 2
                ELSE 3 END
 );
 ```

 Теперь что необходимо связать таблицы «Места» (seats) и «Классы обслуживания» (fare_conditions) по внешнему ключу.
```
 ALTER TABLE seats
    ADD FOREIGN KEY (fare_conditions)
        REFERENCES fare_conditions (fare_conditions_code);
 ```

 Из теории известно, что атрибуты внешнего ключа не обязательно должны ссылаться только на одноименные атрибуты ссылочной
 таблицы. Сейчас на практике успешно проверили это утверждение. Однако для удобства сопровождения базы данных имеет
 смысл переименовать столбец `fare_conditions` в таблице «Места» (seats),  т. е. дать ему имя `fare_conditions_code`,
 поскольку в этой таблице хранится именно код класса обслуживания.
 ```
 ALTER TABLE seats
    RENAME COLUMN fare_conditions TO fare_conditicon_code;
 ```

 Если теперь посмотреть описание таблицы, то можно увидеть, что имя атрибута, являющегося внешним ключом, изменилось,
 а вот имя ограничения `seats_fare_conditions_fkey` осталось неизменным, хотя оно и было первоначально сформировано самой
 СУБД. Это шаблонное имя ограничения составляется из имени таблицы и имени первого (и единственного в данном случае)
 атрибута внешнего ключа. Переименуем это ограничение, чтобы поддержать соблюдение правила именования ограничений:
 ```
 ALTER TABLE seats
    RENAME CONSTRAINT seats_fare_conditions_fkey
    TO seats_fare_conditions_code_fkey;
 ```
 «Наименование класса обслуживания» (fare_conditions_name) также должны быть уникальными, дублирование значений не допускается.
 Добавим ограничение уникальности по этому столбцу:
 ```
 ALTER TABLE fare_conditions ADD UNIQUE ( fare_conditions_name );
 ```




