
 ОСНОВЫ ЯЗЫКА ОПРЕДЕЛЕНИЯ ДАННЫХ
=================================

Представлены 2 таблицы «Студенты» (students) и «Успеваемость» (progress). В первой из них содержатся данные о студентах,
 а во второй — сведения об их успеваемости. Таблица «Успеваемость» будет `ссылающейся (referencing)`, а таблица «Студенты» —
 `ссылочной (referenced)`.

 При работе с БД нередко возникает ситуфция когда значение является типичным для
конкретного столбца(Пример для учета успеваемости студент заслуживает оценки "отлично"
 можно отразить это с помощью ключевогос лова `DEFAULT`)
```sql
CREATE TABLE progress(
...
    mark numeric(1) DEFAULT 5
);
```
# Ограничения (constraints)
## CHECK
После этого ключевого слова следует выражение в скобках, содержащее одно или несколько
условий, налагаемых на атрибуты таблицы. Они бывают 2ух видов:
* ограничение уровня атрибута ( является частью определения одного конкретного атрибута)
```sql
CREATE TABLE progress(
    ...
    term numeric(1) CHECK (term = 1 OR term = 2),
    mark numeric(1) CHECK (mark >= 3 OR mark <=5)
)
```
* уровня таблицы. (записывается как самостоятельный элемент определения таблицы)
```sql
CREATE TABLE progress(
...
    mark numeric(1)
    CONSTRAINT valid_mark CHECK (mark >= 3 OR mark <=5)
)
```
Различие только в синтаксическом оформлении, в ограничении таблицы сделал именованное ограничение,
которое в дольней облегчит понимание возникающих ошибок

### NOT NULL
Оно означает что в столбце таблицы на который наложео ограничение должно обязательно присутсвовать
какие-либо определенные значения

### UNIQUE
это `ограничение уникальности` при наложении на конкретный столбец значит что в этом столбце в различных
строках таблицы должны быть уникальными, т.е. не должны повторяться. Может быть и несколько стольбцов, в этом случае должна
быть уникальной комбинация этих значений
```sql
CREATE TABLE students (
    record_book numeric( 5 ) UNIQUE,
...
```
Это ограничение можно было бы записать и так, дав ему осмысленное имя
```sql
CREATE TABLE students (
    record_book numeric( 5 ),
    name text NOT NULL,
    ...
    CONSTRAINT unique_record_book UNIQUE ( record_book ),
    ...
);
```
комбинация значений серии и номера документа, удостоверяющего личность, является
уникальной. Поэтому можно модифицировать определение таблицы таким образом
```sql
CREATE TABLE students (
    ...
    doc_ser numeric( 4 ),
    doc_num numeric( 6 ),
    ...
    CONSTRAINT unique_passport UNIQUE ( doc_ser, doc_num ),
)
```
При добавлении ограничения уникальности автоматически создается индекс на основе B-дерева для поддержки этого ограничения.

### PRIMARY KEY
 `Первичный ключ` является уникальным идентификатором строк в таблице. Ключ может быть простым (включать только один атрибут),
 так и составным (включать более одного атрибута). Отличие его от UNIQUE, в том что у атрибутов PRIMARY KEY не может быть
 значения NULL. Теория Баз Данных подразумевает что в каждой таблице будет наличие первичного ключа.
 Первичный ключ состоит из одного атрибута, то можно его указать в непосредственно в определении этого атрибута:
 ```sql
 CREATE TABLE students (
    record_book numeric( 5 ) PRIMARY KEY,
    ...
 );
 ```
 В случае создания составного первичного ключа имена столбцов, входящих в его состав, перечисляются в выражении PRIMARY KEY через запятую:
 ```sql
 CREATE TABLE students(
    record_book numeric( 5 ),
    column2 text
    ...
    PRIMARY KEY ( record_book, column2 )
 );
 ```

 При добавлении первичного ключа автоматически создается индекс на основе B-дерева для поддержки этого ограничения.
 В таблице может быть любое число ограничений UNIQUE, дополненных ограничением NOT NULL, но первичный ключ может быть только один.
 PostgreSQL допускает и отсутствие первичного ключа, хотя строгая теория реляционных баз данных не рекомендует так поступать.

### FOREIGN KEY
 `Внешний ключ` - ключ является средством поддержания так называемой `ссылочной целостности (referential integrity)`между
 связанными таблицами

 Достаточно включить в состав каждой строки таблицы «Успеваемость» лишь уникальный идентификатор строки из таблицы «Студенты».
 В нашем случае это будет номер зачетной книжки — `record_book`. Данный атрибут и будет являться внешним ключом таблицы
 «Успеваемость». Таким образом, получив строку из таблицы «Студенты», можно будет найти все соответствующие ей строки
 в таблице «Успеваемость», сопоставив значения атрибутов `record_book` в строках обеих таблиц. В результате мы сможем получить
 все строки таблицы «Успеваемость», связанные с конкретной строкой из таблицы «Студенты» по внешнему ключу.

 Таблица «Успеваемость» будет `ссылающейся (referencing)`, а таблица «Студенты» — `ссылочной (referenced)`.

 Ограничение уровня атрибута:
 ```
 CREATE TABLE progress
 ( record_book numeric( 5 ) REFERENCES students ( record_book ),
     ...
 );
 ```
`REFERENCES` создает ограничение ссылочной целостности и указывает в качестве ссылочного ключа атрибут `record_book`.
Это означает, что в таблицу «Успеваемость» (progress) нельзя ввести строку, значение атрибута record_book которой 
отсутствует в таблице «Студенты» (students).

 Поскольку `внешний ключ` в примере ссылается на `первичный ключ`, можно использовать сокращенную форму записи этого
 ограничения, не указывая список атрибутов:
 ```
 CREATE TABLE progress
 ( record_book numeric( 5 ) REFERENCES students,
 ...
 );
 ```
 Можно определить `внешний ключ` и в форме ограничения уровня таблицы:
 ```
 CREATE TABLE progress (
    record_book numeric( 5 ),
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
 );
```
 ___

 При наличии связей между таблицами, организованных с помощью внешних ключей, необходимо придерживаться определенной
 политики при выполнении операций удаления и обновления строк в ссылочных таблицах, т. е. в тех, на которые ссылаются другие таблицы.
 Cитуация принятия «политического» решения возникает при удалении строк из таблицы «Студенты» (students). Eсли было принято
 решение хранить всю историю успеваемости студентов, в том числе и отчисленных, тогда строки из таблицы students вообще не удалялись бы. Но,
 упрощая реальную ситуацию, решаем историю не хранить. Тогда возникает закономерный вопрос: что делать со строками в
 таблице «Успеваемость» (progress), которые ссылаются на удаляемую строку в таблице «Студенты» (students)? Возможны
 несколько вариантов:
 1. Удаление связанных строк из таблицы «Успеваемость» (progress), что означает, что при отчислении студента будет удаляться вся история его успехов в учебе.
 Эта операция называется каскадным удалением и для ее реализации в определение внешнего ключа добавляются ключевые слова `ON DELETE CASCADE`. Например:

 ```sql
 CREATE TABLE progress (
    record_book numeric( 5 ),
    ...
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON DELETE CASCADE
 );
 ```
 2. Запрет удаления строки из таблицы «Студенты» (students), если в таблице «Успеваемость» (progress) есть хотя бы одна строка,
 ссылающаяся на удаляемую строку в таблице «Студенты».  Kлючевые слова `ON DELETE RESTRICT` или `ON DELETE NO ACTION`. Если в определении внешнего ключа не предписано конкретное
 действие, то по умолчанию используется `NO ACTION`. Оба эти варианта означают, что если в ссылающейся таблице  «Успеваемость»,
 есть строки, ссылающиеся на удаляемую строку в таблице «Студенты», то операция удаления будет отменена, и будет выведено
 сообщение об ошибке. Отличие между этими двумя вариантами лишь в том, что при использовании `NO ACTION` можно отложить проверку
 выполнения ограничения на более поздний строк в рамках транзакции, а в случае `RESTRICT` проверка выполняется немедленно.
```
 CREATE TABLE progress (
    record_book numeric( 5 ),
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON DELETE RESTRICT
 );
 ```
или вот так
 ```
 CREATE TABLE progress
 ( record_book numeric( 5 ),
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
 );
 ```
 То при попытке удаления строки из таблицы «Студенты» и наличии в таблице«Успеваемость» строк, связанных с ней,
 операция удаления была бы отменена с выводом сообщения об ошибке.
3.  Присваивание атрибутам внешнего ключа в строках таблицы «Успеваемость» значения NULL. Для реализации этого
 подхода необходимо, чтобы на атрибуты внешнего ключа не было наложено ограничение NOT NULL.
 ```
 CREATE TABLE progress
 ( record_book numeric( 5 ),
     ...
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON DELETE SET NULL
 );
 ```
 4. Присваивание атрибутам внешнего ключа в строках таблицы «Успеваемость» (progress) значения DEFAULT, если оно, конечно,
 было предписано при создании таблицы. Оформляется этот вариант так (значение во фразе DEFAULT взято произвольное):
```
 CREATE TABLE progress (
    record_book numeric( 5 ) DEFAULT 12345,
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON DELETE SET DEFAULT
 );
 ```
 Важно учитывать, что если в ссылочной таблице нет строки с тем же значением  ключевого атрибута, которое было предписано
 во фразе DEFAULT при создании ссылающейся таблицы, то будет иметь место нарушение ограничения ссылочной целостности и
 операция удаления не будет выполнена

 При выполнении операции UPDATE используются эти же варианты подходов по отношению к обеспечению ссылочной целостности

```
 CREATE TABLE progress (
    record_book numeric( 5 ),
    ...
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON UPDATE CASCADE
 );
```

 После рассмотрения всех видов, ограничений целостности базы данных, можно привести окончательные определения таблиц
 «Студенты» и «Успеваемость». Окончательными они являются лишь в том смысле, что именно их нужно брать за основу
 при выполнении заданий, приведенных в конце главы.
 ___
### Создание и удаление таблиц
Создать базу данных с помощью `docker consol`
```
 creatdb -U app edu
 ```
Подключиться
 ```
 psql -d edu -U app
 ```
`Схема создания таблиц находиться в ch05_work.sql`

 Войти в БД
 ```
 psql -U app -d edu
 ```
 Узнать какие есть схемы в БД
 ```
 SHOW search_path;
 ```
 Если необходимо переключиться к другой БД не выходя из к утилиты psql
 ```
\connect edu
 ```
 или с короткой командой
 ```
 \c edu
 ```
 `Напомнить, что команды, имена которых начинаются с символа «\», не являются
 SQL-командами, а являются командами утилиты psql`

 Выбрать в качестве текущей схемы схему bookings
 ```
 SET search_path TO bookings;
 ```
 `bookings` - это Схема

 `Схема` - это раздел БД в котором создаются таблицы и другие объекты. По умолчанию используется
 схема `public`
При создании таблиц лучше всего добавлять коментарии с помощью ` -- `, а также в Postgres есть команда:
 ```
 COMMENT ON COLUMN table.field IS 'коментарий';
 ```
 Чтобы ы увидеть описания столбцов таблицы:
 ```
 \d+ table
 ```

 `Суррогатный ключ` —  это уникальный ключ, назначение которого — только идентифицировать строки в  таблице. Зачастую для
 него используются целочисленные значения. Такому ключу не  соответствует никакое свойство никакой сущности реального мира.
 Это — абстракция, позволяющая в ряде случаев упростить определения таблиц, например, за счет сокращения числа атрибутов
 во внешних ключах до одного.

 После создания таблиц, посмотреть описание таблиц или таблицы
 ```
 \d
 ```
 ```
 \d boarding_passes
 ```
Попробуем удалить таблицу `aircrafts
 ```
 DROP TABLE aircrafts;
 ```
 Будет выведено сообщение об ошибке, так как эта таблицы является ссылочной, и на нее ссылаются 2 таблицы
 `seats' и `flights` что и отражено в сообщении. Чтобы удалить использовать команду:
 ```
 DROP TABLE aircrafts CASCADE;
 ```
 При этом будет удалены из таблиц `seats' и `flights` внешние ключи, ссылающиеся на удаленную таблицы

 При повторном удалении этой таблицы, =>
 ```
 DROP TABLE aircrafts CASCADE;
 ```
 => будет выведено сообщение об ошибке, что таблица удалена. Чтобы избежать ненужных сообщений об ошибке отсутсвия таблицы
 ```
 DROP TABLE IF EXIST aircrafts CASCADE;
 ```
 `IF EXISTS` будет выведено замечание, а не ошибка. А также об успешном выполнении команды

 _____________________________________________________________
 ## Модификация таблиц
 Модифицировать таблицы приходится по различным причинам. При необходимости добавить к какому-нибудь атрибуту ограничение
 DEFAULT,  можно просто пересоздать, внеся изменения в их определения. Но если таблицы содержат большое
 количество строк, то пересоздать их не всегда возможно, в этом случае на помощь приходит команда `ALTER TABLE`

 `ALTER TABLE` - команда очень многообразна и логична. Она предусматривает все ситуации которые могут возникнуть в реальной
 работе. Ей в этом помогают фразы:

     * `ADD COLUMN` - добавить поле
     * `DROP COLUMN` - удалить поле
     * `ADD CHECK` - добавить
     * `ADD CONSTRAINT` - добавить ограничение
 При попытке выполнить эту команду СУБД выдает сообщение об ошибке
 ```
 ALTER TABLE aircrafts
     ADD COLUMN speed integer NOT NULL CHECK( speed >= 300 );
 ```
 Дело в том, что в таблице
 «Самолеты» (aircrafts) уже есть строки. Однако во время добавления тех строк столбец speed в таблице не присутствовал,
 поэтому при его добавлении сейчас значение  данного атрибута в этих строках будет отсутствовать, т. е. будет равно NULL.
 А мы наложили ограничение NOT NULL, следовательно, ранее добавленные строки не отвечают новому ограничению.

 Решение проблемы:
 1. Сначала добавить столбец, не накладывая никаких ограничений
 ```
 ALTER TABLE aircrafts ADD COLUMN speed integer;
 ```
 2. Ввести значения нового атрибута в уже существующие строки
 ```
 UPDATE aircrafts SET speed = 807 WHERE aircraft_code = '733';
 UPDATE aircrafts SET speed = 851 WHERE aircraft_code = '763';
 UPDATE aircrafts SET speed = 905 WHERE aircraft_code = '773';
 UPDATE aircrafts SET speed = 840
    WHERE aircraft_code IN ( '319', '320', '321' );
 UPDATE aircrafts SET speed = 786 WHERE aircraft_code = 'CR2';
 UPDATE aircrafts SET speed = 341 WHERE aircraft_code = 'CN1';
 UPDATE aircrafts SET speed = 830 WHERE aircraft_code = 'SU9';
 ```
 3. Наложить все необходимые ограничения
 ```
 ALTER TABLE aircrafts ALTER COLUMN speed SET NOT NULL;
 ALTER TABLE aircrafts ADD CHECK( speed >= 300 );
 ```
 Eсли необходимость наличия того или иного ограничения отпадет, его можно удалить:
```
 ALTER TABLE aircrafts ALTER COLUMN speed DROP NOT NULL;
 ALTER TABLE aircrafts DROP CONSTRAINT aircrafts_speed_check;
 ```
ВНИМАНИЕ, для удаления ограничения CHECK нужно указать его имя, которое можно выяснить с помощью команды
`\d aircrafts`

 Изменение типа данных у атрибута. Изменим тип данных для атрибутов «Координаты
 аэропорта: долгота» (longitude) и «Координаты аэропорта: широта» (latitude) с float
 (double precision) на numeric(5, 2)

 ```
 ALTER TABLE airports
    ALTER COLUMN longitude SET DATA TYPE numeric(5, 2)
    ALTER COLUMN latitude SET DATA TYPE numeric(5, 2);
 ```
 Когда один тип данных изменяется на другой тип данных в пределах одной группы, например, оба типа — числовые, то проблем
 обычно не возникает. В только что рассмотренном примере исходный тип данных был float (double precision), а новый —
 numeric(5, 2), поэтому операция замены типа прошла автоматически.Однако если исходный и целевой типы данных относятся к
 разным группам, тогда потребуются некоторые дополнительные усилия.

 Например необходимо создать таблицу, содержащую коды и наименования классов обслуживания. Назовем ее «Классы обслуживания»
 (fare_conditions). В ее состав включим два столбца: «Код класса обслуживания» и «Наименование класса обслуживания». Имена
 столбцам присвоим с учетом принципов формирования имен аналогичных столбцов в других  таблицах, например, в таблице «Аэропорты» (airports).
```
 CREATE TABLE fare_conditions (
    fare_conditions_code integer,
    fare_conditions_name varchar( 10 ) NOT NULL,
    PRIMARY KEY ( fare_conditions_code )
 );
 ```
 Добавить данные:
 ```
 INSERT INTO fare_conditions
    VALUES ( 1, 'Economy' ),
           ( 2, 'Business' ),
           ( 3, 'Comfort' );
 ```
 Поскольку ввели в обращение числовые коды для классов обслуживания, то необходимо модифицировать определение таблицы
 «Места» (seats), а именно: тип данных столбца «Класс обслуживания» (fare_conditions) изменить с varchar(10) на integer.
 Для реализации такой задачи служит фраза USING команды ALTER TABLE. Однако такой вариант команды не сработает:
```
 ALTER TABLE seats
    ALTER COLUMN fare_conditions SET DATA TYPE integer
    USING ( CASE WHEN fare_conditions = 'Economy' THEN 1
                WHEN fare_conditions = 'Business' THEN 2
                ELSE 3
            END );
```
 Для замены исходных значений на новые мы используем конструкцию `CASE WHEN ... THEN ... ELSE ... END`.

В определении таблицы есть ограничение `CHECK`, которое требует, чтобы значение столбца `fare_conditions` выбиралось из списка:
 «Economy», «Comfort», «Business». При замене символьных значений на числовые это ограничение будет заведомо нарушаться.
 Следовательно, необходимо в команду `ALTER TABLE` добавить операцию удаления этого ограничения.
```
 ALTER TABLE seats
    DROP CONSTRAINT seats_fare_conditions_check,
    ALTER COLUMN fare_conditions SET DATA TYPE integer
    USING ( CASE WHEN fare_conditions = 'Economy' THEN 1
                WHEN fare_conditions = 'Business' THEN 2
                ELSE 3 END
 );
 ```

 Теперь что необходимо связать таблицы «Места» (seats) и «Классы обслуживания» (fare_conditions) по внешнему ключу.
```
 ALTER TABLE seats
    ADD FOREIGN KEY (fare_conditions)
        REFERENCES fare_conditions (fare_conditions_code);
 ```

 Из теории известно, что атрибуты внешнего ключа не обязательно должны ссылаться только на одноименные атрибуты ссылочной
 таблицы. Сейчас на практике успешно проверили это утверждение. Однако для удобства сопровождения базы данных имеет
 смысл переименовать столбец `fare_conditions` в таблице «Места» (seats),  т. е. дать ему имя `fare_conditions_code`,
 поскольку в этой таблице хранится именно код класса обслуживания.
 ```
 ALTER TABLE seats
    RENAME COLUMN fare_conditions TO fare_conditicon_code;
 ```

 Если теперь посмотреть описание таблицы, то можно увидеть, что имя атрибута, являющегося внешним ключом, изменилось,
 а вот имя ограничения `seats_fare_conditions_fkey` осталось неизменным, хотя оно и было первоначально сформировано самой
 СУБД. Это шаблонное имя ограничения составляется из имени таблицы и имени первого (и единственного в данном случае)
 атрибута внешнего ключа. Переименуем это ограничение, чтобы поддержать соблюдение правила именования ограничений:
 ```
 ALTER TABLE seats
    RENAME CONSTRAINT seats_fare_conditions_fkey
    TO seats_fare_conditions_code_fkey;
 ```
 «Наименование класса обслуживания» (fare_conditions_name) также должны быть уникальными, дублирование значений не допускается.
 Добавим ограничение уникальности по этому столбцу:
 ```
 ALTER TABLE fare_conditions ADD UNIQUE ( fare_conditions_name );
 ```
__________________________________
 ## Представления

 При работе с базами данных зачастую приходится многократно выполнять одни и те же запросы, которые могут быть весьма
 сложными и требовать обращения к нескольким таблицам. Чтобы избежать необходимости многократного формирования таких
 запросов, можно использовать так называемые `представления (views)`.

 `CREATE VIEW` - создание предсталения, его синтаксис:
 ```
 CREATE VEIW name [(column_name [, ...])]
    AS query;
 ```
 В этой команде обязательными элементами являются `имя представления` и `запрос` к базе данных, который и формирует выборку
 из нее. Если список имен столбцов не приведен, тогда их имена «вычисляются» (формируются) на основании текста запроса.
```
CREATE VIEW seats_by_fare_cond AS
    SELECT aircraft_code, fare_conditions_code, count(*)
    FROM seats
    GROUP BY aircraft_code, fare_conditions_code
    ORDER BY aircraft_code, fare_conditions_code;
 ```
 Вместо написания сложного первоначального запроса обращаться непосредственно к представлению, как будто это обычная таблица
```
 SELECT * FROM seats_by_fare_cond;
 ```
 Фраза `OR REPLACE` - расширение команды `CREATE VIEW`. Если представление уже существует, то можно его не удалять, а просто
 заменить новой версией. Однако нужно помнить о том, что при создании новой версии представления (без явного удаления старой
 с помощью команды `DROP VIEW`)  должны оставаться неизменными имена столбцов представления. Если хотим изменить имя хотя бы
 одного столбца, то сначала нужно удалить представление с помощью команды `DROP VIEW`, а уже затем создать его заново.

 В созданном представлении третий столбец получит имя `count`. Если нужно изменить это имя, то возможны два способа:
    * первый заключается в том, чтобы создать псевдоним для этого столбца с помощью ключевого слова `AS,
    * второй — в использовании списка имен столбцов в начале команды `CREATE VIEW`

 - первый способ
 ```
 CREATE OR REPLACE VIEW seats_by_fare_cond
 AS
    SELECT aircraft_code, fare_conditions_code,
        count(*) AS num_seats
    FROM seats
    GROUP BY aircraft_code, fare_conditions_code
    ORDER BY aircraft_code, fare_conditions_code;
 ```
 * Возникнет ошибка, т.к. при первоначальном создании этого представления третий столбец уже получил имя `count` (такое имя
 ему дала СУБД). Поэтому хотеть воспользоваться вариантом команды с фразой `OR REPLACE`, то не должны изменять названия
 столбцов ни путем указания псевдонимов, ни с помощью списка имен столбцов, приводимого в начале команды. Так что все же
 захотим изменить имя столбца в представлении, придется сначала удалить это представление, а затем создать его заново.
 ```
 DROP VIEW seats_by_fare_cond;
 ```

 - Второй способ, задания имен столбцов в представлении — с помощью списка их имен, заключенного в скобки:
```
 CREATE OR REPLACE VIEW seats_by_fare_cond
    (code, fare_cond, num_seats)
    AS
    SELECT  aircraft_code, fare_conditions_code, count(*)
        FROM seats
        GROUP BY aircraft_code, fare_conditions_code
        ORDER BY aircraft_code, fare_conditions_code;
 ```
 Представления позволяют облегчить развитие и модификацию базы данных, потому  что они могут позволить сохранить интерфейс
 неизменным, но сам запрос, который лежит в основе конкретного представления, может измениться. При этом для прикладного
 программиста представление останется неизменным, поэтому не потребуется переделывать запросы к этому представлению в
 прикладной программе.

 `\d seats_by_fare_cond` - просмотреть представление

 Бывают ситуации, когда заранее известно, что возможна попытка удаления несуществующего представления. В таких случаях
 обычно стараются избежать ненужных сообщений об ошибке отсутствия представления. Делается это путем добавления в команду
 `DROP VIEW` фразы `IF EXISTS`.
 ```
 DROP VIEW IF EXIST seats_by_fare_cond;
 ```
 Представление является фактически сохраненным запросом к базе данных. Этот запрос получает имя, которым можно впоследствии
 воспользоваться в предложении `FROM` команды `SELECT` для получения результатов этого запроса.

 PostgreSQL предлагает свое расширение — так называемое материализованное представление. Упрощенный синтаксис команды
 `CREATE MATERIALIZED VIEW`, предназначенной для создания материализованных представлений, таков:
 ```
 CREATE MATERIALIZED VIEW [ IF NOT EXISTS ] table_name
    [ (column_name [, ...] ) ]
    AS query
    [ WITH [ NO ] DATA ];
 ```
 Материализованное представление заполняется данными в момент выполнения команды для его создания, если только в команде
 не было фразы `WITH NO DATA`. Если же она была включена в команду, тогда в момент своего создания представление данными
 не заполняется, а для заполнения его данными нужно использовать команду `REFRESH MATERIALIZED VIEW`. Mатериализованное
 представление очень похоже на обычную таблицу. Однако оно отличается от таблицы тем, что не только сохраняет данные,
 но также запоминает запрос, с помощью которого эти данные были собраны.
```
 REFRESH MATERIALIZED VIEW routes; -- обновить данные в материализованном представлении
```
 ```
 DROP MATERIALIZED VIEW routes; -- удалить материализованное представление
```
 #### Положительные стороны использования представлений
 1. Упрощение разграничения полномочий пользователей на доступ к хранимым данным.
 Разным типам пользователей могут требоваться различные данные, хранящиеся в одних и тех же таблицах. Это касается как
 столбцов, так и строк таблиц. Создание различных представлений для разных пользователей избавляет от необходимости создавать
 дополнительные таблицы, дублируя данные, и упрощает организацию системы управления доступом к данным.
 2. Упрощение запросов к базе данных.
 Запросы к базе данных могут включать несколько таблиц и быть весьма сложными и громоздкими, при этом такие запросы могут
 выполняться часто. Использование представлений позволяет скрыть эти сложности от прикладного программиста и сделать запросы
 более простыми и наглядными.
 3. Снижение зависимости прикладных программ от изменений структуры таблиц базы данных.
 В процессе развития информационной системы структура таблиц базы данных может изменяться. Столбцы представления, т. е. их
 имена, типы данных и порядок следования, — это, образно говоря, интерфейс к запросу, который реализуется данным представлением.
 Если этот интерфейс остается неизменным, то SQL-запросы, в которых используется данное представление, корректировать не
 потребуется. Нужно будет лишь в ответ на изменение структуры базовых таблиц, на основе которых представление сконструировано,
 соответствующим образом перестроить запрос, выполняемый данным представлением.
 4. Снижение времени выполнения сложных запросов за счет использования материализованных представлений.
 В материализованных представлениях можно сохранять результаты выполнения запросов, которые формируются длительное время,
 но при этом допускают их формирование заранее, а не обязательно в момент возникновения потребности в результатах этого запроса.
 Если, например, какой-нибудь сводный отчет формируется длительное время, а запросы к отчету будут неоднократными, то может
 оказаться целесообразным сформировать его заранее и сохранить в материализованном представлении.

 Одним из недостатков материализованных представлений является то, что их необходимо своевременно обновлять с помощью команды
 `REFRESH`, чтобы они содержали актуальные данные.
 ________________________________________________
 ## Схемы базы данных

 `Схема` - это логический фрагмент базы данных, в котором содержаться различные объекты: таблицы, представления, индексы и др.
 В БД обязательно есть хоть одна схема. При создании базы данных в ней автоматически создаётся схема с именем `public`.
 В каждой базе данных может содержаться более одной схемы. Их имена должны быть уникальными в пределах конкретной базы данных.
 Имена объектов базы данных  (таблиц, представлений, последовательностей и др.)  должны быть уникальными в пределах конкретной
 схемы, но в разных схемах имена объектов могут повторяться. Таким образом, можно сказать, что схема образует так называемое
 пространство имен

 Посмотреть список схем в базе данных
```
 \dn
 ```
 Изменить формат вывода информации, чтобы вернуть в прежнее состояние повторить команду
 ```
 \x
 ```
 Если в базе данных создано более одной схемы, то доступ к объектам, содержащимся в конкретной схеме, можно организовать
 разными способами. Первый заключается в том, чтобы имена объектов предварять именем схемы. Например, для обращения к таблице
`aircrafts` нужно сделать так:
 ```
 SELECT * FROM public.aircrafts;
 ```
Tакой способ не очень удобен. Другой способ заключается в том, чтобы одну из схем сделать текущей. Среди параметров времени
 исполнения, которые предусмотрены в конфигурации сервера PostgreSQL, есть параметр `search_path`. Его значение по умолчанию
 можно изменить в конфигурационном файле `postgresql.conf`. Он содержит имена схем, которые PostgreSQL просматривает при
 поиске конкретного объекта базы данных, когда имя схемы в команде не указано. Посмотреть значение этого параметра можно
 с помощью команды `SHOW`:
 Сначало переключусь на другую БД
 ```
 \c demo
 ```
 Затем:
```
 SHOW search_path;
 ```
 Чтобы изменить порядок просмотра схем при поиске объектов в базе данных, нужно воспользоваться командой SET. При этом
 первой в списке схем следует указать именно ту, которую СУБД должна просматривать первой. Эта схема и станет текущей.
 Конечно, такой список может состоять и всего из одной схемы.
 ```
 SET search_path = bookings;
 ```
 Для обращения к объектам, например, таблицам, в схеме `public` (если бы они в ней были)  нам пришлось бы указывать имя
 схемы `public` перед именами этих объектов. Если бы мы решили добавить схему public в список просматриваемых схем, то
 нужно было бы включить ее в команду `SET`:
 ```
 SET search_path = bookings, public;
 ```
 Узнать имя текущей схемы:
 ```
 SELECT current_schema;
 ```

 При создании объектов базы данных, например, таблиц, необходимо учитывать следующее: если имя схемы в команде не указано,
 то объект будет создан в текущей  схеме. Если же хотите создать объект в конкретной схеме, которая не является текущей,
 то нужно указать ее имя перед именем создаваемого объекта, разделив их точкой. Например, для создания таблицы `airports` в
 схеме `my_schema` следует сделать так:
 ```
 CREATE TABLE my_schema.airports
     ...
 ```





