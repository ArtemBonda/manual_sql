
 ОСНОВЫ ЯЗЫКА ОПРЕДЕЛЕНИЯ ДАННЫХ
=================================

Представлены 2 таблицы «Студенты» (students) и «Успеваемость» (progress). В первой из них содержатся данные о студентах,
 а во второй — сведения об их успеваемости. Таблица «Успеваемость» будет `ссылающейся (referencing)`, а таблица «Студенты» —
 `ссылочной (referenced)`.

 При работе с БД нередко возникает ситуфция когда значение является типичным для
конкретного столбца(Пример для учета успеваемости студент заслуживает оценки "отлично"
 можно отразить это с помощью ключевогос лова `DEFAULT`)
```sql
CREATE TABLE progress(
...
    mark numeric(1) DEFAULT 5
);
```
# Ограничения (constraints)
## CHECK
После этого ключевого слова следует выражение в скобках, содержащее одно или несколько
условий, налагаемых на атрибуты таблицы. Они бывают 2ух видов:
* ограничение уровня атрибута ( является частью определения одного конкретного атрибута)
```sql
CREATE TABLE progress(
    ...
    term numeric(1) CHECK (term = 1 OR term = 2),
    mark numeric(1) CHECK (mark >= 3 OR mark <=5)
)
```
* уровня таблицы. (записывается как самостоятельный элемент определения таблицы)
```sql
CREATE TABLE progress(
...
    mark numeric(1)
    CONSTRAINT valid_mark CHECK (mark >= 3 OR mark <=5)
)
```
Различие только в синтаксическом оформлении, в ограничении таблицы сделал именованное ограничение,
которое в дольней облегчит понимание возникающих ошибок

### NOT NULL
Оно означает что в столбце таблицы на который наложео ограничение должно обязательно присутсвовать
какие-либо определенные значения

### UNIQUE
это `ограничение уникальности` приналожении на конкретный столбец значит что в этом столбце в различных
строках таблицы должны быть уникальными, т.е. не должны повторяться. Может быть и несколько стольбцов, в этом случае должна
быть уникальной комбинация этих значений
```sql
CREATE TABLE students (
    record_book numeric( 5 ) UNIQUE,
...
```
Это ограничение можно было бы записать и так, дав ему осмысленное имя
```sql
CREATE TABLE students (
    record_book numeric( 5 ),
    name text NOT NULL,
    ...
    CONSTRAINT unique_record_book UNIQUE ( record_book ),
    ...
);
```
комбинация значений серии и номера документа, удостоверяющего личность, является
уникальной. Поэтому можно модифицировать определение таблицы таким образом
```sql
CREATE TABLE students (
    ...
    doc_ser numeric( 4 ),
    doc_num numeric( 6 ),
    ...
    CONSTRAINT unique_passport UNIQUE ( doc_ser, doc_num ),
)
```
При добавлении ограничения уникальности автоматически создается индекс на основе B-дерева для поддержки этого ограничения.

### PRIMARY KEY
 `Первичный ключ` является уникальным идентификатором строк в таблице. Ключ может быть простым (включать только один атрибут),
 так и составным (включать более одного атрибута). Отлтчие его от UNIQUE, в том что у атрибутов PRIMARY KEY не может быть
 значения NULL. Теория Баз Данных подразумевает что в каждой таблице будет наличение первичного ключа.
 Первичный ключ состоит из одного атрибута, то можно его указать в непосредственно в определении этого атрибута:
 ```sql
 CREATE TABLE students (
    record_book numeric( 5 ) PRIMARY KEY,
    ...
 );
 ```
 В случае создания составного первичного ключа имена столбцов, входящих в его состав, перечисляются в выражении PRIMARY KEY через запятую:
 ```sql
 CREATE TABLE students(
    record_book numeric( 5 ),
    column2 text
    ...
    PRIMARY KEY ( record_book, column2 )
 );
 ```

 При добавлении первичного ключа автоматически создается индекс на основе B-дерева для поддержки этого ограничения.
 В таблице может быть любое число ограничений UNIQUE, дополненных ограничением NOT NULL, но первичный ключ может быть только один.
 PostgreSQL допускает и отсутствие первичного ключа, хотя строгая теория реляционных баз данных не рекомендует так поступать.

### FOREIGN KEY
 `Внешний ключ` - ключ является средством поддержания так называемой `ссылочной целостности (referential integrity)`между
 связанными таблицами

 Достаточно включить в состав каждой строки таблицы «Успеваемость» лишь уникальный идентификатор строки из таблицы «Студенты».
 В нашем случае это будет номер зачетной книжки — `record_book`. Данный атрибут и будет являться внешним ключом таблицы
 «Успеваемость». Таким образом, получив строку из таблицы «Студенты», можно будет найти все соответствующие ей строки
 в таблице «Успеваемость», сопоставив значения атрибутов `record_book` в строках обеих таблиц. В результате мы сможем получить
 все строки таблицы «Успеваемость», связанные с конкретной строкой из таблицы «Студенты» по внешнему ключу.

 Таблица «Успеваемость» будет `ссылающейся (referencing)`, а таблица «Студенты» — `ссылочной (referenced)`.

 Ограничение уровня атрибута:
 ```
 CREATE TABLE progress
 ( record_book numeric( 5 ) REFERENCES students ( record_book ),
     ...
 );
 ```
`REFERENCES` создает ограничение ссылочной целостности и указывает  в качестве ссылочного ключа атрибут `record_book`

 Поскольку `внешний ключ` в примере ссылается на `первичный ключ`, можно использовать сокращенную форму записи этого
 ограничения, не указывая список атрибутов:
 ```
 CREATE TABLE progress
 ( record_book numeric( 5 ) REFERENCES students,
 ...
 );
 ```
 Можно определить `внешний ключ` и в форме ограничения уровня таблицы:
 ```
 CREATE TABLE progress (
    record_book numeric( 5 ),
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
 );
```
 __________________________________________

 При наличии связей между таблицами, организованных с помощью внешних ключей, необходимо придерживаться определенной
 политики при выполнении операций удаления и обновления строк в ссылочных таблицах, т. е. в тех, на которые ссылаются другие таблицы.
 Cитуация принятия «политического» решения возникает при удалении строк из таблицы «Студенты» (students). Eсли было принято
 решение хранить всю историю успеваемости студентов, в том  числе и отчисленных, тогда строки из таблицы students вообще не удалялись бы. Но,
 упрощая реальную ситуацию, решаеми историю не хранить. Тогда возникает закономерный вопрос: что делать со строками в
 таблице «Успеваемость» (progress), которые ссылаются на удаляемую строку в таблице «Студенты» (students)? Возможны
 несколько вариантов:
 1. Удаление связанных строк из таблицы «Успеваемость» (progress), что означает, что при отчислении студента будет удаляться вся история его успехов в учебе.
 Эта операция называется каскадным удалением и для ее реализации в определение внешнего ключа добавляются ключевые слова `ON DELETE CASCADE`. Например:

 ```sql
 CREATE TABLE progress (
    record_book numeric( 5 ),
    ...
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON DELETE CASCADE
 );
 ```
 2.  . Запрет удаления строки из таблицы «Студенты» (students), если в таблице «Успеваемость» (progress) есть хотя бы одна строка,
 ссылающаяся на удаляемую строку в таблице «Студенты».  Kлючевые слова `ON DELETE RESTRICT` или `ON DELETE NO ACTION`. Если в определении внешнего ключа не предписано конкретное
 действие, то по умолчанию используется `NO ACTION`. Оба эти варианта означают, что если в ссылающейся таблице  «Успеваемость»,
 есть строки, ссылающиеся на удаляемую строку в таблице «Студенты», то операция удаления будет отменена, и будет выведено
 сообщение об ошибке. Отличие между этими двумя вариантами лишь в том, что при использовании `NO ACTION` можно отложить проверку
 выполнения ограничения на более поздний строк в рамках транзакции, а в случае `RESTRICT` проверка выполняется немедленно.
```
 CREATE TABLE progress (
    record_book numeric( 5 ),
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON DELETE RESTRICT
 );
 ```
или вот так
 ```
 CREATE TABLE progress
 ( record_book numeric( 5 ),
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
 );
 ```
 то при попытке удаления строки из таблицы «Студенты» и наличии в таблице«Успеваемость» строк, связанных с ней,
 операция удаления была бы отменена с выводом сообщения об ошибке.
3.  Присваивание атрибутам внешнего ключа в строках таблицы «Успеваемость» значения NULL. Для реализации этого
 подхода необходимо, чтобы на атрибуты внешнего ключа не было наложено ограничение NOT NULL.
 ```
 CREATE TABLE progress
 ( record_book numeric( 5 ),
     ...
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON DELETE SET NULL
 );
 ```
 4. Присваивание атрибутам внешнего ключа в строках таблицы «Успеваемость» (progress) значения DEFAULT, если оно, конечно,
 было предписано при создании таблицы. Оформляется этот вариант так (значение во фразе DEFAULT взято произвольное):
```
 CREATE TABLE progress (
    record_book numeric( 5 ) DEFAULT 12345,
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON DELETE SET DEFAULT
 );
 ```
 Важно учитывать, что если в ссылочной таблице нет строки с тем же значением  ключевого атрибута, которое было предписано
 во фразе DEFAULT при создании ссылающейся таблицы, то будет иметь место нарушение ограничения ссылочной целостности и
 операция удаления не будет выполнена

 При выполнении операции UPDATE используются эти же варианты подходов по отношению к обеспечению ссылочной целостности

```
 CREATE TABLE progress (
    record_book numeric( 5 ),
    ...
    FOREIGN KEY ( record_book )
        REFERENCES students ( record_book )
        ON UPDATE CASCADE
 );
```

 После рассмотрения всех видов ограничений целостности базы данных мы можем  привести окончательные определения таблиц
 «Студенты» и «Успеваемость». Окончательными они являются лишь в том смысле, что именно их нужно брать за основу
 при выполнении заданий, приведенных в конце главы.

 Создать базу данных с помощью docker consol
```
 creatdb -U app edu
 ```
 Подключиться
 ```
 psql -d edu -U app
 ```
 Схема создания таблиц находиться в ch05_work.sql
 __________________________________________
 ## Создание и удаление таблиц
 Войти в БД
 ```
 psql -U app -d demo
 ```
 Узнать какие есть схемы в БД
 ```
 SHOW search_path;
 ```
 Если необходимо переключиться к другой БД не выходя из к утилиты psql
 ```
\connect demo
 ```
 или с короткой командой
 ```
 \c demo
 ```
 `Напомнить, что команды, имена которых начинаются с символа «\», не являются
 SQL-командами, а являются командами утилиты psql`

 Выбрать в качестве текущей схемы схему bookings
 ```
 SET search_path TO bookings;
 ```
 `bookings` - это Схема

 `Схема` - это раздел БД в котором создаются таблицы и другие объекты. По умолчанию используется
 схема `public`
При создании таблиц лучше всего добавлять коментарии с помощью ` -- `, а также в Postgres есть команда:
 ```
 COMMENT ON COLUMN table.field IS 'коментарий';
 ```
 Чтобы ы увидеть описания столбцов таблицы:
 ```
 \d+ table
 ```

 `Суррогатный ключ` —  это уникальный ключ, назначение которого — только идентифицировать строки в  таблице. Зачастую для
 него используются целочисленные значения. Такому ключу не  соответствует никакое свойство никакой сущности реального мира.
 Это — абстракция, позволяющая в ряде случаев упростить определения таблиц, например, за счет сокращения числа атрибутов
 во внешних ключах до одного.





